module statics/calc

imports signatures/- 

signature

  constraint generator
    //Fsm
    [[ Fsm ^ (scope) ]]
    [[ Program ^ (scope) ]]
    [[ Exp ^ (scope) : Type ]]

rules 

  init ^ (s) := new s.
 
  //Begin FSM
  //---------------------------------------------
  //Fsm
  [[ Fsm(states) ^ (fsmScope)]] :=
    //states names have to be unique
    distinct/name D(fsmScope)/State | error $[Duplicate state id] @NAMES,
    //only 1 initial states is allowed
    distinct/name D(fsmScope)/Initial | error $[Multiple initial states] @NAMES,  
    D(fsmScope)/InitialAll seteq/name D(fsmScope)/InitialTest | error $[No initial state],  
    States[[ states ^ (fsmScope) ]]. 

  //Traverse List of States
  States[[ [ state | states ] ^ (fsmScope) ]] :=
    State[[ state ^ (fsmScope) ]],
    States[[ states ^ (fsmScope) ]].
  
  // Initial state, handle separatly(e.g. always reachable, Unique initial state)
  State[[ State(Some(Initial()),id,transitions) ^ (fsmScope) ]] :=
  	//register State(id) in fsmScope    
  	State{id} <- fsmScope,
  	InitialAll{"init"} <- fsmScope,
    //create stateScope, valid inside the state to test if Transition(input) is unique, i.e. the Transition is ambiguous
    new stateScope,
    distinct/name D(stateScope)/Transition | error $[Ambiguous transition] @NAMES,
    Transitions[[ transitions ^ (fsmScope, stateScope) ]],
    //initial specific part
  	Initial{Some(Initial())} <- fsmScope,
  	InitialTest{"init"} <- fsmScope.
  
  // State (non initial) 
  State[[ State(None(),id,transitions) ^ (fsmScope) ]] :=
  	//register State(id) in fsmScope    
  	State{id} <- fsmScope,
  	InitialAll{"init"} <- fsmScope,
    //create stateScope, valid inside the state to test if Transition(input) is unique, i.e. the Transition is ambiguous
    new stateScope,
    distinct/name D(stateScope)/Transition | error $[Ambiguous transition] @NAMES,
    Transitions[[ transitions ^ (fsmScope, stateScope) ]],
    //non initial specific part
    TransitionTarget{id} -> fsmScope,
    //The references must be a subset or equal to the definitions
 	R(fsmScope)/TransitionTarget subseteq/name D(fsmScope)/TransitionTarget | warning $[Unreachable state] @NAMES.


  //Traverse List of Transitions
  Transitions[[ [ transition | transitions ] ^ (fsmScope, stateScope) ]] :=
    Transition[[ transition ^ (fsmScope, stateScope) ]],
    Transitions[[ transitions ^ (fsmScope, stateScope) ]].
  
   //Allow empty states
   Transitions [[ [] ^ (_,_) ]].
    
   Transition[[ Transition(input, action, target) ^ (fsmScope, stateScope) ]]:= 
     //reigster Transition(input) in stateScope, to test ambiguous input names
     Transition{input} <- stateScope,
     [[ input ^ (fsmScope, stateScope) ]],
     [[ action ^ (fsmScope, stateScope) ]], 
     [[ target ^ (fsmScope, stateScope) ]]. 
   
   //Target (optional)  
   [[ Some(Target(target)) ^ (fsmScope, stateScope) ]]:=
     TransitionTarget{target} <- fsmScope,
     State{target} -> fsmScope,
 	 State{target} |-> d | error $[Target state [target] not definied].
   
   //Matches any (Fsm/Transition/)Input
   [[ Input(_) ^ (_,_) ]].
   //Used for (Fsm/Transition/)Action and Target beacause they are optional 
   [[ Some(_) ^ (_,_) ]].
   [[ None() ^ (_,_) ]].
   
   
   //-------------------------------------------------------
   //End FSM
  
    [[ Program(stats) ^ (s) ]] := 
    new s', s' ---> s,
    Stats[[ stats ^ (s') ]].
 
  
  Stats[[ [ stat | stats ] ^ (s) ]] :=
    Stat[[ stat ^ (s, s_nxt) ]],
    Stats[[ stats ^ (s_nxt) ]].
    
  Stat[[ Bind(x, e) ^ (s, s') ]] := 
    s' == s_nxt,
    new s_nxt, s_nxt ---> s,
    {x} <- s_nxt, {x} genOf ty,
    [[ e ^ (s) : ty ]].
    
  Stat[[ Exp(e) ^ (s, s_nxt) ]] := 
    s == s_nxt,
    [[ e ^ (s) : ty ]].

rules // numbers
    
  [[ Num(x) ^ (s) : NumT() ]].
  
  [[ Pow(e1, e2) ^ (s) : NumT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]]. 
  [[ Mul(e1, e2) ^ (s) : NumT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]]. 
  [[ Add(e1, e2) ^ (s) : NumT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]]. 
  [[ Sub(e1, e2) ^ (s) : NumT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]].  
  [[ Div(e1, e2) ^ (s) : NumT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]].
   
  [[ Eq(e1, e2) ^ (s)  : BoolT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]].
  [[ Lt(e1, e2) ^ (s)  : BoolT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]].

rules // booleans
  
  [[ True()  ^ (s) : BoolT() ]].
  [[ False() ^ (s) : BoolT() ]].
  
  [[ If(e1, e2, e3) ^ (s) : ty2 ]] := 
     [[ e1 ^ (s) : BoolT() ]], 
     [[ e2 ^ (s) : ty2 ]], 
     [[ e3 ^ (s) : ty3 ]],
     ty2 == ty3 | error $[branches should have same type] @ e2.

rules // variables and functions

  [[ Var(x) ^ (s) : ty ]] := 
    {x} -> s, {x} |-> d, ty instOf d.
    
  [[ Let(x, e1, e2) ^ (s) : ty2 ]] := 
     new s', {x} <- s', {x} : ty, s' -P-> s, 
     [[ e1 ^ (s)  : ty ]], 
     [[ e2 ^ (s') : ty2 ]].
    
  [[ Fun([x], e) ^ (s) : FunT(ty1, ty2) ]] :=
     new s', {x} <- s', {x} : ty1, s' -P-> s, 
     [[ e ^ (s') : ty2 ]].
     
  [[ App(e1, e2) ^ (s) : ty2 ]] := 
     [[ e1 ^ (s) : FunT(ty1, ty2) ]], 
     [[ e2 ^ (s) : ty1 ]].