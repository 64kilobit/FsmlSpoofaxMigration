module statics/calc

imports signatures/- 

signature

  constraint generator
    //Fsm
    [[ Fsm ^ (scope) ]]
    [[ Program ^ (scope) ]]
    [[ Exp ^ (scope) : Type ]]
//    Stat[[ Stat ^ (scope, scope) ]]

rules 

  init ^ (s) := new s.
 
 //Beginn FSM
 //---------------------------------------------
  [[ Fsm(states) ^ (fsmScope)]] :=
    distinct/name D(fsmScope)/Sta | error $[Duplicate state id] @NAMES,
    distinct/name D(fsmScope)/Init | error $[Multiple initial states] @NAMES,  
    D(fsmScope)/InitAll seteq/name D(fsmScope)/InitTest | error $[No initial state] @NAMES,  
    States[[ states ^ (fsmScope) ]]. 

  States[[ [ state | states ] ^ (fsmScope) ]] :=
    State[[ state ^ (fsmScope) ]],
    States[[ states ^ (fsmScope) ]].
  
  State[[ State(Some(Initial()),id,transitions) ^ (fsmScope) ]] :=
    //register State(id) in fsmScope    
  	Sta{id} <- fsmScope,
  	Init{Some(Initial())} <- fsmScope,
  	InitAll{"test"} <- fsmScope,
  	InitTest{"test"} <- fsmScope,
    //create stateScope, valid inside 1 state to test if Transition(input) in the current state are ambiguous
    new stateScope,
    distinct/name D(stateScope)/Trans | error $[Ambiguous transition] @NAMES,
    Transitions[[ transitions ^ (fsmScope, stateScope) ]].
    
  State[[ State(None(),id,transitions) ^ (fsmScope) ]] :=
    //register State(id) in fsmScope    
  	Sta{id} <- fsmScope,
  	InitAll{"test"} <- fsmScope,
    //create stateScope, valid inside 1 state to test if Transition(input) in the current state are ambiguous
    new stateScope,
    distinct/name D(stateScope)/Trans | error $[Ambiguous transition] @NAMES,
    Transitions[[ transitions ^ (fsmScope, stateScope) ]].   
       

  Transitions[[ [ transition | transitions ] ^ (fsmScope, stateScope) ]] :=
    Transition[[ transition ^ (fsmScope, stateScope) ]],
    Transitions[[ transitions ^ (fsmScope, stateScope) ]].
    
   Transition[[ Transition(input, action, target) ^ (fsmScope, stateScope) ]]:= 
     //reigster Transition(input), to test ambiguous input names
     Trans{input} <- stateScope,
//     [[ input ^ (stateScope, stateScope) : Input(input) ]],
//     [[ action ^ (stateScope, stateScope) : Action(action) ]], 
     [[ target ^ (fsmScope, stateScope) ]]. 
     
   [[ Some(Target(target)) ^ (fsmScope, stateScope) ]]:=
     Sta{target} -> fsmScope,
 	 Sta{target} |-> d | error $[Target state [target] not definied].
   
   [[ Input(_) ^ (_,_) : _ ]].
   [[ None() ^ (_,_) ]].
   
   
   //-------------------------------------------------------
   //End FSM
  
    [[ Program(stats) ^ (s) ]] := 
    new s', s' ---> s,
    Stats[[ stats ^ (s') ]].
 
  
  Stats[[ [ stat | stats ] ^ (s) ]] :=
    Stat[[ stat ^ (s, s_nxt) ]],
    Stats[[ stats ^ (s_nxt) ]].
    
  Stat[[ Bind(x, e) ^ (s, s') ]] := 
    s' == s_nxt,
    new s_nxt, s_nxt ---> s,
    {x} <- s_nxt, {x} genOf ty,
    [[ e ^ (s) : ty ]].
    
  Stat[[ Exp(e) ^ (s, s_nxt) ]] := 
    s == s_nxt,
    [[ e ^ (s) : ty ]].

rules // numbers
    
  [[ Num(x) ^ (s) : NumT() ]].
  
  [[ Pow(e1, e2) ^ (s) : NumT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]]. 
  [[ Mul(e1, e2) ^ (s) : NumT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]]. 
  [[ Add(e1, e2) ^ (s) : NumT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]]. 
  [[ Sub(e1, e2) ^ (s) : NumT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]].  
  [[ Div(e1, e2) ^ (s) : NumT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]].
   
  [[ Eq(e1, e2) ^ (s)  : BoolT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]].
  [[ Lt(e1, e2) ^ (s)  : BoolT() ]] := 
     [[ e1 ^ (s) : NumT() ]], 
     [[ e2 ^ (s) : NumT() ]].

rules // booleans
  
  [[ True()  ^ (s) : BoolT() ]].
  [[ False() ^ (s) : BoolT() ]].
  
  [[ If(e1, e2, e3) ^ (s) : ty2 ]] := 
     [[ e1 ^ (s) : BoolT() ]], 
     [[ e2 ^ (s) : ty2 ]], 
     [[ e3 ^ (s) : ty3 ]],
     ty2 == ty3 | error $[branches should have same type] @ e2.

rules // variables and functions

  [[ Var(x) ^ (s) : ty ]] := 
    {x} -> s, {x} |-> d, ty instOf d.
    
  [[ Let(x, e1, e2) ^ (s) : ty2 ]] := 
     new s', {x} <- s', {x} : ty, s' -P-> s, 
     [[ e1 ^ (s)  : ty ]], 
     [[ e2 ^ (s') : ty2 ]].
    
  [[ Fun([x], e) ^ (s) : FunT(ty1, ty2) ]] :=
     new s', {x} <- s', {x} : ty1, s' -P-> s, 
     [[ e ^ (s') : ty2 ]].
     
  [[ App(e1, e2) ^ (s) : ty2 ]] := 
     [[ e1 ^ (s) : FunT(ty1, ty2) ]], 
     [[ e2 ^ (s) : ty1 ]].